from casadi import *
import numpy as np
from MPC_tutorial import plot_solution

def get_x_next_linear(x_current, u_current):
    A = np.array([[1. , 0.1],
                  [0. , 1. ]])
    B = np.array([[0.005],
                  [0.1  ]])
    x_next = A@x_current + B@u_current # @'s are for matrix multiplication, *'s are for element-wise multiplication
    return x_next

def get_x_total(x_hat, u, get_x_next_symbolic_func):
    x_k = x_hat
    x_tot = [x_k]
    for k in range(u.shape[0]):
        u_k = u[k]
        x_k = get_x_next_symbolic_func(x_k, u_k)
        x_tot.append(x_k)
    return x_tot

def solve_IVP(x_hat_numeric, u_numeric):
    # get state and control dimensions
    n = x_hat_numeric.shape[0] # state dimension
    m = u_numeric.shape[0] # control dimension
    K = u_numeric.shape[1] # horizon length

    # set up casadi symbolic functions
    x_current = MX.sym('x_current', n)
    u_current = MX.sym('u_current', m)
    get_x_next_symbolic_func = Function('get_x_next_symbolic_func', [x_current, u_current], [get_x_next_linear(x_current, u_current)])

    x_hat = MX.sym('x_hat', n)
    u = MX.sym('u', K*m)
    get_x_total_symbolic_func = Function('get_x_total_symbolic_func', [x_hat, u], get_x_total(x_hat, u, get_x_next_symbolic_func))
    
    return get_x_total_symbolic_func(x_hat_numeric, u_numeric)

if __name__ == "__main__":
    x_hat_numeric = np.array([[1],[1]]) # 2 x 1 vector
    u_numeric = np.array([-10, -10, -10, 5, 5, 5, -2, -2, 2, 2, 2, 2, -1, -1, 1, 1, 1]).reshape(1,-1) # 1 x 17 vector

    n = x_hat_numeric.shape[0]
    m = u_numeric.shape[0]

    x_tot_numeric = solve_IVP(x_hat_numeric, u_numeric)
    
    x_tot_numeric_list = [np.array(x).reshape(n,1) for x in x_tot_numeric] # convert to n x (K+1)
    u_numeric_list = [np.array(u) for u in u_numeric[0]]
    plot_solution(x_tot_numeric_list, u_numeric_list)